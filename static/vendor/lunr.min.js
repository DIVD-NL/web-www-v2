/**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9
 * Copyright (C) 2020 Oliver Nightingale
 * @license MIT
 */
!(function () {
  const e = function (t) {
    const r = new e.Builder();
    return (
      r.pipeline.add(e.trimmer, e.stopWordFilter, e.stemmer), r.searchPipeline.add(e.stemmer), t.call(r, r), r.build()
    );
  };
  (e.version = '2.3.9'),
    (e.utils = {}),
    (e.utils.warn = (function (e) {
      return function (t) {
        e.console && console.warn && console.warn(t);
      };
    })(this)),
    (e.utils.asString = function (e) {
      return void 0 === e || e === null ? '' : e.toString();
    }),
    (e.utils.clone = function (e) {
      if (e === null || void 0 === e) return e;
      for (var t = Object.create(null), r = Object.keys(e), i = 0; i < r.length; i++) {
        const n = r[i];
        const s = e[n];
        if (Array.isArray(s)) t[n] = s.slice();
        else {
          if (typeof s !== 'string' && typeof s !== 'number' && typeof s !== 'boolean')
            throw new TypeError('clone is not deep and does not support nested objects');
          t[n] = s;
        }
      }
      return t;
    }),
    (e.FieldRef = function (e, t, r) {
      (this.docRef = e), (this.fieldName = t), (this._stringValue = r);
    }),
    (e.FieldRef.joiner = '/'),
    (e.FieldRef.fromString = function (t) {
      const r = t.indexOf(e.FieldRef.joiner);
      if (r === -1) throw 'malformed field ref string';
      const i = t.slice(0, r);
      const n = t.slice(r + 1);
      return new e.FieldRef(n, i, t);
    }),
    (e.FieldRef.prototype.toString = function () {
      return (
        void 0 == this._stringValue && (this._stringValue = this.fieldName + e.FieldRef.joiner + this.docRef),
        this._stringValue
      );
    }),
    (e.Set = function (e) {
      if (((this.elements = Object.create(null)), e)) {
        this.length = e.length;
        for (let t = 0; t < this.length; t++) this.elements[e[t]] = !0;
      } else this.length = 0;
    }),
    (e.Set.complete = {
      intersect(e) {
        return e;
      },
      union() {
        return this;
      },
      contains() {
        return !0;
      },
    }),
    (e.Set.empty = {
      intersect() {
        return this;
      },
      union(e) {
        return e;
      },
      contains() {
        return !1;
      },
    }),
    (e.Set.prototype.contains = function (e) {
      return !!this.elements[e];
    }),
    (e.Set.prototype.intersect = function (t) {
      let r;
      let i;
      let n;
      const s = [];
      if (t === e.Set.complete) return this;
      if (t === e.Set.empty) return t;
      this.length < t.length ? ((r = this), (i = t)) : ((r = t), (i = this)), (n = Object.keys(r.elements));
      for (let o = 0; o < n.length; o++) {
        const a = n[o];
        a in i.elements && s.push(a);
      }
      return new e.Set(s);
    }),
    (e.Set.prototype.union = function (t) {
      return t === e.Set.complete
        ? e.Set.complete
        : t === e.Set.empty
          ? this
          : new e.Set(Object.keys(this.elements).concat(Object.keys(t.elements)));
    }),
    (e.idf = function (e, t) {
      let r = 0;
      for (const i in e) i != '_index' && (r += Object.keys(e[i]).length);
      const n = (t - r + 0.5) / (r + 0.5);
      return Math.log(1 + Math.abs(n));
    }),
    (e.Token = function (e, t) {
      (this.str = e || ''), (this.metadata = t || {});
    }),
    (e.Token.prototype.toString = function () {
      return this.str;
    }),
    (e.Token.prototype.update = function (e) {
      return (this.str = e(this.str, this.metadata)), this;
    }),
    (e.Token.prototype.clone = function (t) {
      return (
        (t =
          t ||
          function (e) {
            return e;
          }),
        new e.Token(t(this.str, this.metadata), this.metadata)
      );
    }),
    (e.tokenizer = function (t, r) {
      if (t == null || void 0 == t) return [];
      if (Array.isArray(t)) return t.map((t) => new e.Token(e.utils.asString(t).toLowerCase(), e.utils.clone(r)));
      for (var i = t.toString().toLowerCase(), n = i.length, s = [], o = 0, a = 0; o <= n; o++) {
        const u = i.charAt(o);
        const l = o - a;
        if (u.match(e.tokenizer.separator) || o == n) {
          if (l > 0) {
            const c = e.utils.clone(r) || {};
            (c.position = [a, l]), (c.index = s.length), s.push(new e.Token(i.slice(a, o), c));
          }
          a = o + 1;
        }
      }
      return s;
    }),
    (e.tokenizer.separator = /[\s\-]+/),
    (e.Pipeline = function () {
      this._stack = [];
    }),
    (e.Pipeline.registeredFunctions = Object.create(null)),
    (e.Pipeline.registerFunction = function (t, r) {
      r in this.registeredFunctions && e.utils.warn(`Overwriting existing registered function: ${r}`),
        (t.label = r),
        (e.Pipeline.registeredFunctions[t.label] = t);
    }),
    (e.Pipeline.warnIfFunctionNotRegistered = function (t) {
      const r = t.label && t.label in this.registeredFunctions;
      r ||
        e.utils.warn(
          'Function is not registered with pipeline. This may cause problems when serialising the index.\n',
          t,
        );
    }),
    (e.Pipeline.load = function (t) {
      const r = new e.Pipeline();
      return (
        t.forEach((t) => {
          const i = e.Pipeline.registeredFunctions[t];
          if (!i) throw new Error(`Cannot load unregistered function: ${t}`);
          r.add(i);
        }),
        r
      );
    }),
    (e.Pipeline.prototype.add = function () {
      const t = Array.prototype.slice.call(arguments);
      t.forEach(function (t) {
        e.Pipeline.warnIfFunctionNotRegistered(t), this._stack.push(t);
      }, this);
    }),
    (e.Pipeline.prototype.after = function (t, r) {
      e.Pipeline.warnIfFunctionNotRegistered(r);
      let i = this._stack.indexOf(t);
      if (i == -1) throw new Error('Cannot find existingFn');
      (i += 1), this._stack.splice(i, 0, r);
    }),
    (e.Pipeline.prototype.before = function (t, r) {
      e.Pipeline.warnIfFunctionNotRegistered(r);
      const i = this._stack.indexOf(t);
      if (i == -1) throw new Error('Cannot find existingFn');
      this._stack.splice(i, 0, r);
    }),
    (e.Pipeline.prototype.remove = function (e) {
      const t = this._stack.indexOf(e);
      t != -1 && this._stack.splice(t, 1);
    }),
    (e.Pipeline.prototype.run = function (e) {
      for (let t = this._stack.length, r = 0; r < t; r++) {
        for (var i = this._stack[r], n = [], s = 0; s < e.length; s++) {
          const o = i(e[s], s, e);
          if (o !== null && void 0 !== o && o !== '')
            if (Array.isArray(o)) for (let a = 0; a < o.length; a++) n.push(o[a]);
            else n.push(o);
        }
        e = n;
      }
      return e;
    }),
    (e.Pipeline.prototype.runString = function (t, r) {
      const i = new e.Token(t, r);
      return this.run([i]).map((e) => e.toString());
    }),
    (e.Pipeline.prototype.reset = function () {
      this._stack = [];
    }),
    (e.Pipeline.prototype.toJSON = function () {
      return this._stack.map((t) => (e.Pipeline.warnIfFunctionNotRegistered(t), t.label));
    }),
    (e.Vector = function (e) {
      (this._magnitude = 0), (this.elements = e || []);
    }),
    (e.Vector.prototype.positionForIndex = function (e) {
      if (this.elements.length == 0) return 0;
      for (
        var t = 0, r = this.elements.length / 2, i = r - t, n = Math.floor(i / 2), s = this.elements[2 * n];
        i > 1 && (s < e && (t = n), s > e && (r = n), s != e);

      )
        (i = r - t), (n = t + Math.floor(i / 2)), (s = this.elements[2 * n]);
      return s == e ? 2 * n : s > e ? 2 * n : s < e ? 2 * (n + 1) : void 0;
    }),
    (e.Vector.prototype.insert = function (e, t) {
      this.upsert(e, t, () => {
        throw 'duplicate index';
      });
    }),
    (e.Vector.prototype.upsert = function (e, t, r) {
      this._magnitude = 0;
      const i = this.positionForIndex(e);
      this.elements[i] == e ? (this.elements[i + 1] = r(this.elements[i + 1], t)) : this.elements.splice(i, 0, e, t);
    }),
    (e.Vector.prototype.magnitude = function () {
      if (this._magnitude) return this._magnitude;
      for (var e = 0, t = this.elements.length, r = 1; r < t; r += 2) {
        const i = this.elements[r];
        e += i * i;
      }
      return (this._magnitude = Math.sqrt(e));
    }),
    (e.Vector.prototype.dot = function (e) {
      for (
        var t = 0, r = this.elements, i = e.elements, n = r.length, s = i.length, o = 0, a = 0, u = 0, l = 0;
        u < n && l < s;

      )
        (o = r[u]),
          (a = i[l]),
          o < a ? (u += 2) : o > a ? (l += 2) : o == a && ((t += r[u + 1] * i[l + 1]), (u += 2), (l += 2));
      return t;
    }),
    (e.Vector.prototype.similarity = function (e) {
      return this.dot(e) / this.magnitude() || 0;
    }),
    (e.Vector.prototype.toArray = function () {
      for (var e = new Array(this.elements.length / 2), t = 1, r = 0; t < this.elements.length; t += 2, r++)
        e[r] = this.elements[t];
      return e;
    }),
    (e.Vector.prototype.toJSON = function () {
      return this.elements;
    }),
    (e.stemmer = (function () {
      const e = {
        ational: 'ate',
        tional: 'tion',
        enci: 'ence',
        anci: 'ance',
        izer: 'ize',
        bli: 'ble',
        alli: 'al',
        entli: 'ent',
        eli: 'e',
        ousli: 'ous',
        ization: 'ize',
        ation: 'ate',
        ator: 'ate',
        alism: 'al',
        iveness: 'ive',
        fulness: 'ful',
        ousness: 'ous',
        aliti: 'al',
        iviti: 'ive',
        biliti: 'ble',
        logi: 'log',
      };
      const t = {
        icate: 'ic',
        ative: '',
        alize: 'al',
        iciti: 'ic',
        ical: 'ic',
        ful: '',
        ness: '',
      };
      const r = '[^aeiou]';
      const i = '[aeiouy]';
      const n = `${r}[^aeiouy]*`;
      const s = `${i}[aeiou]*`;
      const o = `^(${n})?${s}${n}`;
      const a = `^(${n})?${s}${n}(${s})?$`;
      const u = `^(${n})?${s}${n}${s}${n}`;
      const l = `^(${n})?${i}`;
      const c = new RegExp(o);
      const h = new RegExp(u);
      const d = new RegExp(a);
      const f = new RegExp(l);
      const p = /^(.+?)(ss|i)es$/;
      const y = /^(.+?)([^s])s$/;
      const m = /^(.+?)eed$/;
      const v = /^(.+?)(ed|ing)$/;
      const g = /.$/;
      const x = /(at|bl|iz)$/;
      const w = new RegExp('([^aeiouylsz])\\1$');
      const Q = new RegExp(`^${n}${i}[^aeiouwxy]$`);
      const k = /^(.+?[^aeiou])y$/;
      const S =
        /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
      const E = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
      const L = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
      const b = /^(.+?)(s|t)(ion)$/;
      const P = /^(.+?)e$/;
      const T = /ll$/;
      const O = new RegExp(`^${n}${i}[^aeiouwxy]$`);
      const I = function (r) {
        let i;
        let n;
        let s;
        let o;
        let a;
        let u;
        let l;
        if (r.length < 3) return r;
        if (
          ((s = r.substr(0, 1)),
          s == 'y' && (r = s.toUpperCase() + r.substr(1)),
          (o = p),
          (a = y),
          o.test(r) ? (r = r.replace(o, '$1$2')) : a.test(r) && (r = r.replace(a, '$1$2')),
          (o = m),
          (a = v),
          o.test(r))
        ) {
          var I = o.exec(r);
          (o = c), o.test(I[1]) && ((o = g), (r = r.replace(o, '')));
        } else if (a.test(r)) {
          var I = a.exec(r);
          (i = I[1]),
            (a = f),
            a.test(i) &&
              ((r = i),
              (a = x),
              (u = w),
              (l = Q),
              a.test(r) ? (r += 'e') : u.test(r) ? ((o = g), (r = r.replace(o, ''))) : l.test(r) && (r += 'e'));
        }
        if (((o = k), o.test(r))) {
          var I = o.exec(r);
          (i = I[1]), (r = `${i}i`);
        }
        if (((o = S), o.test(r))) {
          var I = o.exec(r);
          (i = I[1]), (n = I[2]), (o = c), o.test(i) && (r = i + e[n]);
        }
        if (((o = E), o.test(r))) {
          var I = o.exec(r);
          (i = I[1]), (n = I[2]), (o = c), o.test(i) && (r = i + t[n]);
        }
        if (((o = L), (a = b), o.test(r))) {
          var I = o.exec(r);
          (i = I[1]), (o = h), o.test(i) && (r = i);
        } else if (a.test(r)) {
          var I = a.exec(r);
          (i = I[1] + I[2]), (a = h), a.test(i) && (r = i);
        }
        if (((o = P), o.test(r))) {
          var I = o.exec(r);
          (i = I[1]), (o = h), (a = d), (u = O), (o.test(i) || (a.test(i) && !u.test(i))) && (r = i);
        }
        return (
          (o = T),
          (a = h),
          o.test(r) && a.test(r) && ((o = g), (r = r.replace(o, ''))),
          s == 'y' && (r = s.toLowerCase() + r.substr(1)),
          r
        );
      };
      return function (e) {
        return e.update(I);
      };
    })()),
    e.Pipeline.registerFunction(e.stemmer, 'stemmer'),
    (e.generateStopWordFilter = function (e) {
      const t = e.reduce((e, t) => ((e[t] = t), e), {});
      return function (e) {
        if (e && t[e.toString()] !== e.toString()) return e;
      };
    }),
    (e.stopWordFilter = e.generateStopWordFilter([
      'a',
      'able',
      'about',
      'across',
      'after',
      'all',
      'almost',
      'also',
      'am',
      'among',
      'an',
      'and',
      'any',
      'are',
      'as',
      'at',
      'be',
      'because',
      'been',
      'but',
      'by',
      'can',
      'cannot',
      'could',
      'dear',
      'did',
      'do',
      'does',
      'either',
      'else',
      'ever',
      'every',
      'for',
      'from',
      'get',
      'got',
      'had',
      'has',
      'have',
      'he',
      'her',
      'hers',
      'him',
      'his',
      'how',
      'however',
      'i',
      'if',
      'in',
      'into',
      'is',
      'it',
      'its',
      'just',
      'least',
      'let',
      'like',
      'likely',
      'may',
      'me',
      'might',
      'most',
      'must',
      'my',
      'neither',
      'no',
      'nor',
      'not',
      'of',
      'off',
      'often',
      'on',
      'only',
      'or',
      'other',
      'our',
      'own',
      'rather',
      'said',
      'say',
      'says',
      'she',
      'should',
      'since',
      'so',
      'some',
      'than',
      'that',
      'the',
      'their',
      'them',
      'then',
      'there',
      'these',
      'they',
      'this',
      'tis',
      'to',
      'too',
      'twas',
      'us',
      'wants',
      'was',
      'we',
      'were',
      'what',
      'when',
      'where',
      'which',
      'while',
      'who',
      'whom',
      'why',
      'will',
      'with',
      'would',
      'yet',
      'you',
      'your',
    ])),
    e.Pipeline.registerFunction(e.stopWordFilter, 'stopWordFilter'),
    (e.trimmer = function (e) {
      return e.update((e) => e.replace(/^\W+/, '').replace(/\W+$/, ''));
    }),
    e.Pipeline.registerFunction(e.trimmer, 'trimmer'),
    (e.TokenSet = function () {
      (this.final = !1), (this.edges = {}), (this.id = e.TokenSet._nextId), (e.TokenSet._nextId += 1);
    }),
    (e.TokenSet._nextId = 1),
    (e.TokenSet.fromArray = function (t) {
      for (var r = new e.TokenSet.Builder(), i = 0, n = t.length; i < n; i++) r.insert(t[i]);
      return r.finish(), r.root;
    }),
    (e.TokenSet.fromClause = function (t) {
      return 'editDistance' in t ? e.TokenSet.fromFuzzyString(t.term, t.editDistance) : e.TokenSet.fromString(t.term);
    }),
    (e.TokenSet.fromFuzzyString = function (t, r) {
      for (var i = new e.TokenSet(), n = [{ node: i, editsRemaining: r, str: t }]; n.length; ) {
        const s = n.pop();
        if (s.str.length > 0) {
          var o;
          const a = s.str.charAt(0);
          a in s.node.edges ? (o = s.node.edges[a]) : ((o = new e.TokenSet()), (s.node.edges[a] = o)),
            s.str.length == 1 && (o.final = !0),
            n.push({ node: o, editsRemaining: s.editsRemaining, str: s.str.slice(1) });
        }
        if (s.editsRemaining != 0) {
          if ('*' in s.node.edges) var u = s.node.edges['*'];
          else {
            var u = new e.TokenSet();
            s.node.edges['*'] = u;
          }
          if (
            (s.str.length == 0 && (u.final = !0),
            n.push({ node: u, editsRemaining: s.editsRemaining - 1, str: s.str }),
            s.str.length > 1 && n.push({ node: s.node, editsRemaining: s.editsRemaining - 1, str: s.str.slice(1) }),
            s.str.length == 1 && (s.node.final = !0),
            s.str.length >= 1)
          ) {
            if ('*' in s.node.edges) var l = s.node.edges['*'];
            else {
              var l = new e.TokenSet();
              s.node.edges['*'] = l;
            }
            s.str.length == 1 && (l.final = !0),
              n.push({ node: l, editsRemaining: s.editsRemaining - 1, str: s.str.slice(1) });
          }
          if (s.str.length > 1) {
            var c;
            const h = s.str.charAt(0);
            const d = s.str.charAt(1);
            d in s.node.edges ? (c = s.node.edges[d]) : ((c = new e.TokenSet()), (s.node.edges[d] = c)),
              s.str.length == 1 && (c.final = !0),
              n.push({ node: c, editsRemaining: s.editsRemaining - 1, str: h + s.str.slice(2) });
          }
        }
      }
      return i;
    }),
    (e.TokenSet.fromString = function (t) {
      for (var r = new e.TokenSet(), i = r, n = 0, s = t.length; n < s; n++) {
        const o = t[n];
        const a = n == s - 1;
        if (o == '*') (r.edges[o] = r), (r.final = a);
        else {
          const u = new e.TokenSet();
          (u.final = a), (r.edges[o] = u), (r = u);
        }
      }
      return i;
    }),
    (e.TokenSet.prototype.toArray = function () {
      for (var e = [], t = [{ prefix: '', node: this }]; t.length; ) {
        const r = t.pop();
        const i = Object.keys(r.node.edges);
        const n = i.length;
        r.node.final && (r.prefix.charAt(0), e.push(r.prefix));
        for (let s = 0; s < n; s++) {
          const o = i[s];
          t.push({ prefix: r.prefix.concat(o), node: r.node.edges[o] });
        }
      }
      return e;
    }),
    (e.TokenSet.prototype.toString = function () {
      if (this._str) return this._str;
      for (var e = this.final ? '1' : '0', t = Object.keys(this.edges).sort(), r = t.length, i = 0; i < r; i++) {
        const n = t[i];
        const s = this.edges[n];
        e = e + n + s.id;
      }
      return e;
    }),
    (e.TokenSet.prototype.intersect = function (t) {
      for (var r = new e.TokenSet(), i = void 0, n = [{ qNode: t, output: r, node: this }]; n.length; ) {
        i = n.pop();
        for (
          let s = Object.keys(i.qNode.edges), o = s.length, a = Object.keys(i.node.edges), u = a.length, l = 0;
          l < o;
          l++
        )
          for (let c = s[l], h = 0; h < u; h++) {
            const d = a[h];
            if (d == c || c == '*') {
              const f = i.node.edges[d];
              const p = i.qNode.edges[c];
              const y = f.final && p.final;
              let m = void 0;
              d in i.output.edges
                ? ((m = i.output.edges[d]), (m.final = m.final || y))
                : ((m = new e.TokenSet()), (m.final = y), (i.output.edges[d] = m)),
                n.push({ qNode: p, output: m, node: f });
            }
          }
      }
      return r;
    }),
    (e.TokenSet.Builder = function () {
      (this.previousWord = ''), (this.root = new e.TokenSet()), (this.uncheckedNodes = []), (this.minimizedNodes = {});
    }),
    (e.TokenSet.Builder.prototype.insert = function (t) {
      let r;
      let i = 0;
      if (t < this.previousWord) throw new Error('Out of order word insertion');
      for (var n = 0; n < t.length && n < this.previousWord.length && t[n] == this.previousWord[n]; n++) i++;
      this.minimize(i),
        (r = this.uncheckedNodes.length == 0 ? this.root : this.uncheckedNodes[this.uncheckedNodes.length - 1].child);
      for (var n = i; n < t.length; n++) {
        const s = new e.TokenSet();
        const o = t[n];
        (r.edges[o] = s), this.uncheckedNodes.push({ parent: r, char: o, child: s }), (r = s);
      }
      (r.final = !0), (this.previousWord = t);
    }),
    (e.TokenSet.Builder.prototype.finish = function () {
      this.minimize(0);
    }),
    (e.TokenSet.Builder.prototype.minimize = function (e) {
      for (let t = this.uncheckedNodes.length - 1; t >= e; t--) {
        const r = this.uncheckedNodes[t];
        const i = r.child.toString();
        i in this.minimizedNodes
          ? (r.parent.edges[r.char] = this.minimizedNodes[i])
          : ((r.child._str = i), (this.minimizedNodes[i] = r.child)),
          this.uncheckedNodes.pop();
      }
    }),
    (e.Index = function (e) {
      (this.invertedIndex = e.invertedIndex),
        (this.fieldVectors = e.fieldVectors),
        (this.tokenSet = e.tokenSet),
        (this.fields = e.fields),
        (this.pipeline = e.pipeline);
    }),
    (e.Index.prototype.search = function (t) {
      return this.query((r) => {
        const i = new e.QueryParser(t, r);
        i.parse();
      });
    }),
    (e.Index.prototype.query = function (t) {
      for (
        var r = new e.Query(this.fields),
          i = Object.create(null),
          n = Object.create(null),
          s = Object.create(null),
          o = Object.create(null),
          a = Object.create(null),
          u = 0;
        u < this.fields.length;
        u++
      )
        n[this.fields[u]] = new e.Vector();
      t.call(r, r);
      for (var u = 0; u < r.clauses.length; u++) {
        const l = r.clauses[u];
        let c = null;
        let h = e.Set.empty;
        c = l.usePipeline ? this.pipeline.runString(l.term, { fields: l.fields }) : [l.term];
        for (let d = 0; d < c.length; d++) {
          const f = c[d];
          l.term = f;
          const p = e.TokenSet.fromClause(l);
          const y = this.tokenSet.intersect(p).toArray();
          if (y.length === 0 && l.presence === e.Query.presence.REQUIRED) {
            for (var m = 0; m < l.fields.length; m++) {
              var v = l.fields[m];
              o[v] = e.Set.empty;
            }
            break;
          }
          for (let g = 0; g < y.length; g++)
            for (var x = y[g], w = this.invertedIndex[x], Q = w._index, m = 0; m < l.fields.length; m++) {
              var v = l.fields[m];
              const k = w[v];
              const S = Object.keys(k);
              const E = `${x}/${v}`;
              const L = new e.Set(S);
              if (
                (l.presence == e.Query.presence.REQUIRED &&
                  ((h = h.union(L)), void 0 === o[v] && (o[v] = e.Set.complete)),
                l.presence != e.Query.presence.PROHIBITED)
              ) {
                if ((n[v].upsert(Q, l.boost, (e, t) => e + t), !s[E])) {
                  for (let b = 0; b < S.length; b++) {
                    var P;
                    const T = S[b];
                    var O = new e.FieldRef(T, v);
                    const I = k[T];
                    void 0 === (P = i[O]) ? (i[O] = new e.MatchData(x, v, I)) : P.add(x, v, I);
                  }
                  s[E] = !0;
                }
              } else void 0 === a[v] && (a[v] = e.Set.empty), (a[v] = a[v].union(L));
            }
        }
        if (l.presence === e.Query.presence.REQUIRED)
          for (var m = 0; m < l.fields.length; m++) {
            var v = l.fields[m];
            o[v] = o[v].intersect(h);
          }
      }
      for (var R = e.Set.complete, F = e.Set.empty, u = 0; u < this.fields.length; u++) {
        var v = this.fields[u];
        o[v] && (R = R.intersect(o[v])), a[v] && (F = F.union(a[v]));
      }
      let C = Object.keys(i);
      const N = [];
      const _ = Object.create(null);
      if (r.isNegated()) {
        C = Object.keys(this.fieldVectors);
        for (var u = 0; u < C.length; u++) {
          var O = C[u];
          var j = e.FieldRef.fromString(O);
          i[O] = new e.MatchData();
        }
      }
      for (var u = 0; u < C.length; u++) {
        var j = e.FieldRef.fromString(C[u]);
        const D = j.docRef;
        if (R.contains(D) && !F.contains(D)) {
          var A;
          const B = this.fieldVectors[j];
          const V = n[j.fieldName].similarity(B);
          if (void 0 !== (A = _[D])) (A.score += V), A.matchData.combine(i[j]);
          else {
            const z = { ref: D, score: V, matchData: i[j] };
            (_[D] = z), N.push(z);
          }
        }
      }
      return N.sort((e, t) => t.score - e.score);
    }),
    (e.Index.prototype.toJSON = function () {
      const t = Object.keys(this.invertedIndex)
        .sort()
        .map(function (e) {
          return [e, this.invertedIndex[e]];
        }, this);
      const r = Object.keys(this.fieldVectors).map(function (e) {
        return [e, this.fieldVectors[e].toJSON()];
      }, this);
      return {
        version: e.version,
        fields: this.fields,
        fieldVectors: r,
        invertedIndex: t,
        pipeline: this.pipeline.toJSON(),
      };
    }),
    (e.Index.load = function (t) {
      const r = {};
      const i = {};
      const n = t.fieldVectors;
      const s = Object.create(null);
      const o = t.invertedIndex;
      const a = new e.TokenSet.Builder();
      const u = e.Pipeline.load(t.pipeline);
      t.version != e.version &&
        e.utils.warn(
          `Version mismatch when loading serialised index. Current version of lunr '${e.version}' does not match serialized index '${t.version}'`,
        );
      for (var l = 0; l < n.length; l++) {
        var c = n[l];
        const h = c[0];
        const d = c[1];
        i[h] = new e.Vector(d);
      }
      for (var l = 0; l < o.length; l++) {
        var c = o[l];
        const f = c[0];
        const p = c[1];
        a.insert(f), (s[f] = p);
      }
      return (
        a.finish(),
        (r.fields = t.fields),
        (r.fieldVectors = i),
        (r.invertedIndex = s),
        (r.tokenSet = a.root),
        (r.pipeline = u),
        new e.Index(r)
      );
    }),
    (e.Builder = function () {
      (this._ref = 'id'),
        (this._fields = Object.create(null)),
        (this._documents = Object.create(null)),
        (this.invertedIndex = Object.create(null)),
        (this.fieldTermFrequencies = {}),
        (this.fieldLengths = {}),
        (this.tokenizer = e.tokenizer),
        (this.pipeline = new e.Pipeline()),
        (this.searchPipeline = new e.Pipeline()),
        (this.documentCount = 0),
        (this._b = 0.75),
        (this._k1 = 1.2),
        (this.termIndex = 0),
        (this.metadataWhitelist = []);
    }),
    (e.Builder.prototype.ref = function (e) {
      this._ref = e;
    }),
    (e.Builder.prototype.field = function (e, t) {
      if (/\//.test(e)) throw new RangeError(`Field '${e}' contains illegal character '/'`);
      this._fields[e] = t || {};
    }),
    (e.Builder.prototype.b = function (e) {
      e < 0 ? (this._b = 0) : e > 1 ? (this._b = 1) : (this._b = e);
    }),
    (e.Builder.prototype.k1 = function (e) {
      this._k1 = e;
    }),
    (e.Builder.prototype.add = function (t, r) {
      const i = t[this._ref];
      const n = Object.keys(this._fields);
      (this._documents[i] = r || {}), (this.documentCount += 1);
      for (let s = 0; s < n.length; s++) {
        const o = n[s];
        const a = this._fields[o].extractor;
        const u = a ? a(t) : t[o];
        const l = this.tokenizer(u, { fields: [o] });
        const c = this.pipeline.run(l);
        const h = new e.FieldRef(i, o);
        const d = Object.create(null);
        (this.fieldTermFrequencies[h] = d), (this.fieldLengths[h] = 0), (this.fieldLengths[h] += c.length);
        for (let f = 0; f < c.length; f++) {
          const p = c[f];
          if ((void 0 == d[p] && (d[p] = 0), (d[p] += 1), void 0 == this.invertedIndex[p])) {
            const y = Object.create(null);
            (y._index = this.termIndex), (this.termIndex += 1);
            for (let m = 0; m < n.length; m++) y[n[m]] = Object.create(null);
            this.invertedIndex[p] = y;
          }
          void 0 == this.invertedIndex[p][o][i] && (this.invertedIndex[p][o][i] = Object.create(null));
          for (let v = 0; v < this.metadataWhitelist.length; v++) {
            const g = this.metadataWhitelist[v];
            const x = p.metadata[g];
            void 0 == this.invertedIndex[p][o][i][g] && (this.invertedIndex[p][o][i][g] = []),
              this.invertedIndex[p][o][i][g].push(x);
          }
        }
      }
    }),
    (e.Builder.prototype.calculateAverageFieldLengths = function () {
      for (var t = Object.keys(this.fieldLengths), r = t.length, i = {}, n = {}, s = 0; s < r; s++) {
        const o = e.FieldRef.fromString(t[s]);
        const a = o.fieldName;
        n[a] || (n[a] = 0), (n[a] += 1), i[a] || (i[a] = 0), (i[a] += this.fieldLengths[o]);
      }
      for (var u = Object.keys(this._fields), s = 0; s < u.length; s++) {
        const l = u[s];
        i[l] = i[l] / n[l];
      }
      this.averageFieldLength = i;
    }),
    (e.Builder.prototype.createFieldVectors = function () {
      for (
        var t = {}, r = Object.keys(this.fieldTermFrequencies), i = r.length, n = Object.create(null), s = 0;
        s < i;
        s++
      ) {
        for (
          var o = e.FieldRef.fromString(r[s]),
            a = o.fieldName,
            u = this.fieldLengths[o],
            l = new e.Vector(),
            c = this.fieldTermFrequencies[o],
            h = Object.keys(c),
            d = h.length,
            f = this._fields[a].boost || 1,
            p = this._documents[o.docRef].boost || 1,
            y = 0;
          y < d;
          y++
        ) {
          var m;
          var v;
          var g;
          const x = h[y];
          const w = c[x];
          const Q = this.invertedIndex[x]._index;
          void 0 === n[x] ? ((m = e.idf(this.invertedIndex[x], this.documentCount)), (n[x] = m)) : (m = n[x]),
            (v =
              (m * ((this._k1 + 1) * w)) / (this._k1 * (1 - this._b + this._b * (u / this.averageFieldLength[a])) + w)),
            (v *= f),
            (v *= p),
            (g = Math.round(1e3 * v) / 1e3),
            l.insert(Q, g);
        }
        t[o] = l;
      }
      this.fieldVectors = t;
    }),
    (e.Builder.prototype.createTokenSet = function () {
      this.tokenSet = e.TokenSet.fromArray(Object.keys(this.invertedIndex).sort());
    }),
    (e.Builder.prototype.build = function () {
      return (
        this.calculateAverageFieldLengths(),
        this.createFieldVectors(),
        this.createTokenSet(),
        new e.Index({
          invertedIndex: this.invertedIndex,
          fieldVectors: this.fieldVectors,
          tokenSet: this.tokenSet,
          fields: Object.keys(this._fields),
          pipeline: this.searchPipeline,
        })
      );
    }),
    (e.Builder.prototype.use = function (e) {
      const t = Array.prototype.slice.call(arguments, 1);
      t.unshift(this), e.apply(this, t);
    }),
    (e.MatchData = function (e, t, r) {
      for (var i = Object.create(null), n = Object.keys(r || {}), s = 0; s < n.length; s++) {
        const o = n[s];
        i[o] = r[o].slice();
      }
      (this.metadata = Object.create(null)),
        void 0 !== e && ((this.metadata[e] = Object.create(null)), (this.metadata[e][t] = i));
    }),
    (e.MatchData.prototype.combine = function (e) {
      for (let t = Object.keys(e.metadata), r = 0; r < t.length; r++) {
        const i = t[r];
        const n = Object.keys(e.metadata[i]);
        void 0 == this.metadata[i] && (this.metadata[i] = Object.create(null));
        for (let s = 0; s < n.length; s++) {
          const o = n[s];
          const a = Object.keys(e.metadata[i][o]);
          void 0 == this.metadata[i][o] && (this.metadata[i][o] = Object.create(null));
          for (let u = 0; u < a.length; u++) {
            const l = a[u];
            void 0 == this.metadata[i][o][l]
              ? (this.metadata[i][o][l] = e.metadata[i][o][l])
              : (this.metadata[i][o][l] = this.metadata[i][o][l].concat(e.metadata[i][o][l]));
          }
        }
      }
    }),
    (e.MatchData.prototype.add = function (e, t, r) {
      if (!(e in this.metadata)) return (this.metadata[e] = Object.create(null)), void (this.metadata[e][t] = r);
      if (!(t in this.metadata[e])) return void (this.metadata[e][t] = r);
      for (let i = Object.keys(r), n = 0; n < i.length; n++) {
        const s = i[n];
        s in this.metadata[e][t]
          ? (this.metadata[e][t][s] = this.metadata[e][t][s].concat(r[s]))
          : (this.metadata[e][t][s] = r[s]);
      }
    }),
    (e.Query = function (e) {
      (this.clauses = []), (this.allFields = e);
    }),
    (e.Query.wildcard = new String('*')),
    (e.Query.wildcard.NONE = 0),
    (e.Query.wildcard.LEADING = 1),
    (e.Query.wildcard.TRAILING = 2),
    (e.Query.presence = { OPTIONAL: 1, REQUIRED: 2, PROHIBITED: 3 }),
    (e.Query.prototype.clause = function (t) {
      return (
        'fields' in t || (t.fields = this.allFields),
        'boost' in t || (t.boost = 1),
        'usePipeline' in t || (t.usePipeline = !0),
        'wildcard' in t || (t.wildcard = e.Query.wildcard.NONE),
        t.wildcard & e.Query.wildcard.LEADING && t.term.charAt(0) != e.Query.wildcard && (t.term = `*${t.term}`),
        t.wildcard & e.Query.wildcard.TRAILING && t.term.slice(-1) != e.Query.wildcard && (t.term = `${t.term}*`),
        'presence' in t || (t.presence = e.Query.presence.OPTIONAL),
        this.clauses.push(t),
        this
      );
    }),
    (e.Query.prototype.isNegated = function () {
      for (let t = 0; t < this.clauses.length; t++)
        if (this.clauses[t].presence != e.Query.presence.PROHIBITED) return !1;
      return !0;
    }),
    (e.Query.prototype.term = function (t, r) {
      if (Array.isArray(t))
        return (
          t.forEach(function (t) {
            this.term(t, e.utils.clone(r));
          }, this),
          this
        );
      const i = r || {};
      return (i.term = t.toString()), this.clause(i), this;
    }),
    (e.QueryParseError = function (e, t, r) {
      (this.name = 'QueryParseError'), (this.message = e), (this.start = t), (this.end = r);
    }),
    (e.QueryParseError.prototype = new Error()),
    (e.QueryLexer = function (e) {
      (this.lexemes = []),
        (this.str = e),
        (this.length = e.length),
        (this.pos = 0),
        (this.start = 0),
        (this.escapeCharPositions = []);
    }),
    (e.QueryLexer.prototype.run = function () {
      for (let t = e.QueryLexer.lexText; t; ) t = t(this);
    }),
    (e.QueryLexer.prototype.sliceString = function () {
      for (var e = [], t = this.start, r = this.pos, i = 0; i < this.escapeCharPositions.length; i++)
        (r = this.escapeCharPositions[i]), e.push(this.str.slice(t, r)), (t = r + 1);
      return e.push(this.str.slice(t, this.pos)), (this.escapeCharPositions.length = 0), e.join('');
    }),
    (e.QueryLexer.prototype.emit = function (e) {
      this.lexemes.push({
        type: e,
        str: this.sliceString(),
        start: this.start,
        end: this.pos,
      }),
        (this.start = this.pos);
    }),
    (e.QueryLexer.prototype.escapeCharacter = function () {
      this.escapeCharPositions.push(this.pos - 1), (this.pos += 1);
    }),
    (e.QueryLexer.prototype.next = function () {
      if (this.pos >= this.length) return e.QueryLexer.EOS;
      const t = this.str.charAt(this.pos);
      return (this.pos += 1), t;
    }),
    (e.QueryLexer.prototype.width = function () {
      return this.pos - this.start;
    }),
    (e.QueryLexer.prototype.ignore = function () {
      this.start == this.pos && (this.pos += 1), (this.start = this.pos);
    }),
    (e.QueryLexer.prototype.backup = function () {
      this.pos -= 1;
    }),
    (e.QueryLexer.prototype.acceptDigitRun = function () {
      let t;
      let r;
      do (t = this.next()), (r = t.charCodeAt(0));
      while (r > 47 && r < 58);
      t != e.QueryLexer.EOS && this.backup();
    }),
    (e.QueryLexer.prototype.more = function () {
      return this.pos < this.length;
    }),
    (e.QueryLexer.EOS = 'EOS'),
    (e.QueryLexer.FIELD = 'FIELD'),
    (e.QueryLexer.TERM = 'TERM'),
    (e.QueryLexer.EDIT_DISTANCE = 'EDIT_DISTANCE'),
    (e.QueryLexer.BOOST = 'BOOST'),
    (e.QueryLexer.PRESENCE = 'PRESENCE'),
    (e.QueryLexer.lexField = function (t) {
      return t.backup(), t.emit(e.QueryLexer.FIELD), t.ignore(), e.QueryLexer.lexText;
    }),
    (e.QueryLexer.lexTerm = function (t) {
      if ((t.width() > 1 && (t.backup(), t.emit(e.QueryLexer.TERM)), t.ignore(), t.more())) return e.QueryLexer.lexText;
    }),
    (e.QueryLexer.lexEditDistance = function (t) {
      return t.ignore(), t.acceptDigitRun(), t.emit(e.QueryLexer.EDIT_DISTANCE), e.QueryLexer.lexText;
    }),
    (e.QueryLexer.lexBoost = function (t) {
      return t.ignore(), t.acceptDigitRun(), t.emit(e.QueryLexer.BOOST), e.QueryLexer.lexText;
    }),
    (e.QueryLexer.lexEOS = function (t) {
      t.width() > 0 && t.emit(e.QueryLexer.TERM);
    }),
    (e.QueryLexer.termSeparator = e.tokenizer.separator),
    (e.QueryLexer.lexText = function (t) {
      for (;;) {
        const r = t.next();
        if (r == e.QueryLexer.EOS) return e.QueryLexer.lexEOS;
        if (r.charCodeAt(0) != 92) {
          if (r == ':') return e.QueryLexer.lexField;
          if (r == '~') return t.backup(), t.width() > 0 && t.emit(e.QueryLexer.TERM), e.QueryLexer.lexEditDistance;
          if (r == '^') return t.backup(), t.width() > 0 && t.emit(e.QueryLexer.TERM), e.QueryLexer.lexBoost;
          if (r == '+' && t.width() === 1) return t.emit(e.QueryLexer.PRESENCE), e.QueryLexer.lexText;
          if (r == '-' && t.width() === 1) return t.emit(e.QueryLexer.PRESENCE), e.QueryLexer.lexText;
          if (r.match(e.QueryLexer.termSeparator)) return e.QueryLexer.lexTerm;
        } else t.escapeCharacter();
      }
    }),
    (e.QueryParser = function (t, r) {
      (this.lexer = new e.QueryLexer(t)), (this.query = r), (this.currentClause = {}), (this.lexemeIdx = 0);
    }),
    (e.QueryParser.prototype.parse = function () {
      this.lexer.run(), (this.lexemes = this.lexer.lexemes);
      for (let t = e.QueryParser.parseClause; t; ) t = t(this);
      return this.query;
    }),
    (e.QueryParser.prototype.peekLexeme = function () {
      return this.lexemes[this.lexemeIdx];
    }),
    (e.QueryParser.prototype.consumeLexeme = function () {
      const e = this.peekLexeme();
      return (this.lexemeIdx += 1), e;
    }),
    (e.QueryParser.prototype.nextClause = function () {
      const e = this.currentClause;
      this.query.clause(e), (this.currentClause = {});
    }),
    (e.QueryParser.parseClause = function (t) {
      const r = t.peekLexeme();
      if (void 0 != r)
        switch (r.type) {
          case e.QueryLexer.PRESENCE:
            return e.QueryParser.parsePresence;
          case e.QueryLexer.FIELD:
            return e.QueryParser.parseField;
          case e.QueryLexer.TERM:
            return e.QueryParser.parseTerm;
          default:
            var i = `expected either a field or a term, found ${r.type}`;
            throw (r.str.length >= 1 && (i += ` with value '${r.str}'`), new e.QueryParseError(i, r.start, r.end));
        }
    }),
    (e.QueryParser.parsePresence = function (t) {
      const r = t.consumeLexeme();
      if (void 0 != r) {
        switch (r.str) {
          case '-':
            t.currentClause.presence = e.Query.presence.PROHIBITED;
            break;
          case '+':
            t.currentClause.presence = e.Query.presence.REQUIRED;
            break;
          default:
            var i = `unrecognised presence operator'${r.str}'`;
            throw new e.QueryParseError(i, r.start, r.end);
        }
        const n = t.peekLexeme();
        if (void 0 == n) {
          var i = 'expecting term or field, found nothing';
          throw new e.QueryParseError(i, r.start, r.end);
        }
        switch (n.type) {
          case e.QueryLexer.FIELD:
            return e.QueryParser.parseField;
          case e.QueryLexer.TERM:
            return e.QueryParser.parseTerm;
          default:
            var i = `expecting term or field, found '${n.type}'`;
            throw new e.QueryParseError(i, n.start, n.end);
        }
      }
    }),
    (e.QueryParser.parseField = function (t) {
      const r = t.consumeLexeme();
      if (void 0 != r) {
        if (t.query.allFields.indexOf(r.str) == -1) {
          const i = t.query.allFields.map((e) => `'${e}'`).join(', ');
          var n = `unrecognised field '${r.str}', possible fields: ${i}`;
          throw new e.QueryParseError(n, r.start, r.end);
        }
        t.currentClause.fields = [r.str];
        const s = t.peekLexeme();
        if (void 0 == s) {
          var n = 'expecting term, found nothing';
          throw new e.QueryParseError(n, r.start, r.end);
        }
        switch (s.type) {
          case e.QueryLexer.TERM:
            return e.QueryParser.parseTerm;
          default:
            var n = `expecting term, found '${s.type}'`;
            throw new e.QueryParseError(n, s.start, s.end);
        }
      }
    }),
    (e.QueryParser.parseTerm = function (t) {
      const r = t.consumeLexeme();
      if (void 0 != r) {
        (t.currentClause.term = r.str.toLowerCase()), r.str.indexOf('*') != -1 && (t.currentClause.usePipeline = !1);
        const i = t.peekLexeme();
        if (void 0 == i) return void t.nextClause();
        switch (i.type) {
          case e.QueryLexer.TERM:
            return t.nextClause(), e.QueryParser.parseTerm;
          case e.QueryLexer.FIELD:
            return t.nextClause(), e.QueryParser.parseField;
          case e.QueryLexer.EDIT_DISTANCE:
            return e.QueryParser.parseEditDistance;
          case e.QueryLexer.BOOST:
            return e.QueryParser.parseBoost;
          case e.QueryLexer.PRESENCE:
            return t.nextClause(), e.QueryParser.parsePresence;
          default:
            var n = `Unexpected lexeme type '${i.type}'`;
            throw new e.QueryParseError(n, i.start, i.end);
        }
      }
    }),
    (e.QueryParser.parseEditDistance = function (t) {
      const r = t.consumeLexeme();
      if (void 0 != r) {
        const i = parseInt(r.str, 10);
        if (isNaN(i)) {
          var n = 'edit distance must be numeric';
          throw new e.QueryParseError(n, r.start, r.end);
        }
        t.currentClause.editDistance = i;
        const s = t.peekLexeme();
        if (void 0 == s) return void t.nextClause();
        switch (s.type) {
          case e.QueryLexer.TERM:
            return t.nextClause(), e.QueryParser.parseTerm;
          case e.QueryLexer.FIELD:
            return t.nextClause(), e.QueryParser.parseField;
          case e.QueryLexer.EDIT_DISTANCE:
            return e.QueryParser.parseEditDistance;
          case e.QueryLexer.BOOST:
            return e.QueryParser.parseBoost;
          case e.QueryLexer.PRESENCE:
            return t.nextClause(), e.QueryParser.parsePresence;
          default:
            var n = `Unexpected lexeme type '${s.type}'`;
            throw new e.QueryParseError(n, s.start, s.end);
        }
      }
    }),
    (e.QueryParser.parseBoost = function (t) {
      const r = t.consumeLexeme();
      if (void 0 != r) {
        const i = parseInt(r.str, 10);
        if (isNaN(i)) {
          var n = 'boost must be numeric';
          throw new e.QueryParseError(n, r.start, r.end);
        }
        t.currentClause.boost = i;
        const s = t.peekLexeme();
        if (void 0 == s) return void t.nextClause();
        switch (s.type) {
          case e.QueryLexer.TERM:
            return t.nextClause(), e.QueryParser.parseTerm;
          case e.QueryLexer.FIELD:
            return t.nextClause(), e.QueryParser.parseField;
          case e.QueryLexer.EDIT_DISTANCE:
            return e.QueryParser.parseEditDistance;
          case e.QueryLexer.BOOST:
            return e.QueryParser.parseBoost;
          case e.QueryLexer.PRESENCE:
            return t.nextClause(), e.QueryParser.parsePresence;
          default:
            var n = `Unexpected lexeme type '${s.type}'`;
            throw new e.QueryParseError(n, s.start, s.end);
        }
      }
    }),
    (function (e, t) {
      typeof define === 'function' && define.amd
        ? define(t)
        : typeof exports === 'object'
          ? (module.exports = t())
          : (e.lunr = t());
    })(this, () => e);
})();
