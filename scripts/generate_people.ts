/**
 * Script to generate people pages from Google Forms responses
 * Generated at: 2025-02-12 13:09:15 UTC
 * Generated by: MagicLegend
 *
 * This script processes Google Form responses to:
 * - Generate individual markdown files for team members
 * - Download and process profile pictures
 * - Update team assignments in the team index file
 * - Handle social media links and other profile information
 */

import { google } from 'googleapis';
import { promises as fs } from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { createHash } from 'crypto';
import { GaxiosResponse } from 'gaxios';

/**
 * List of all known teams in the organization.
 * Used for validation and type safety.
 */
const KNOWN_TEAMS = [
  'Board',
  'Management',
  'DIVD-CSIRT',
  'Research & Development',
  'IT Services',
  'People & Culture',
  'Communications',
  'Governance, Risk & Compliance (GRC)',
  'Project Office',
  'Advisory Board',
  'Ethics Committee',
  'Confidentiality Officers',
] as const;

type TeamName = (typeof KNOWN_TEAMS)[number];

/**
 * Structure of the teams index file frontmatter
 */
interface TeamsIndex {
  title: string;
  opener: string;
  intro: string;
  in_progress: boolean;
  teams: Array<{
    title: TeamName;
    description: string;
    members: string[];
  }>;
}

/**
 * Internal representation of a person's data after processing
 */
interface PersonData {
  timestamp: string;
  email: string;
  consent: string;
  firstName: string;
  lastName: string;
  about: string;
  teams: TeamName[];
  socialLinks: {
    linkedin?: string;
    twitter?: string;
    facebook?: string;
    website?: string;
  };
  profilePicture?: string;
}

/**
 * Configuration for mapping form fields to internal data structure
 */
interface FormFieldMapping {
  headerNames: {
    timestamp: string;
    email: string;
    consent: string;
    firstName: string;
    lastName: string;
    about: string;
    teams: string;
    linkedin: string;
    twitter: string;
    facebook: string;
    website: string;
    profilePicture: string;
  };
  validation: {
    consent: {
      validValues: string[];
      transform?: (value: string) => string;
    };
    teams: {
      separator: string;
      validValues: readonly string[];
    };
  };
}

/**
 * Default form field mappings and validation rules
 */
const DEFAULT_FORM_MAPPING: FormFieldMapping = {
  headerNames: {
    timestamp: 'Timestamp',
    email: 'Email Address',
    consent: 'I agree that the information I entered in this form will be visible publicly on https://divd.nl',
    firstName: 'First name',
    lastName: 'Last name',
    about: 'About you',
    teams: 'Select your team(s)',
    linkedin: 'LinkedIn',
    twitter: 'Twitter',
    facebook: 'Facebook',
    website: 'Website (your blog, etc)',
    profilePicture: 'Profile picture',
  },
  validation: {
    consent: {
      validValues: ['yes', 'agree'],
      transform: (value: string) => value.toLowerCase(),
    },
    teams: {
      separator: ',',
      validValues: KNOWN_TEAMS,
    },
  },
};

type SocialPlatform = 'linkedin' | 'twitter' | 'facebook' | 'website';

/**
 * Structure of the frontmatter for individual people markdown files
 */
interface PeopleMarkdownFrontmatter {
  type: 'people';
  title: string;
  image: string;
  role: string;
  intro: string;
  links: Array<{
    platform: SocialPlatform;
    url: string;
  }>;
  csirt_cases: string[];
  csirt_posts: string[];
  cve_records: string[];
  description: string;
}

/**
 * Global configuration interface
 */
interface Config {
  readonly spreadsheetId: string;
  readonly outputDir: string;
  readonly imagesDir: string;
  readonly teamsIndexPath: string;
  readonly formMapping: FormFieldMapping;
}

const SCOPES: string[] = [
  'https://www.googleapis.com/auth/spreadsheets.readonly',
  'https://www.googleapis.com/auth/drive.readonly',
];

/**
 * Handles the processing of form responses and field mapping
 */
class FormProcessor {
  private headerRow: string[] = [];
  private headerIndices: Map<string, number> = new Map();
  private formMapping: FormFieldMapping;

  constructor(formMapping: FormFieldMapping) {
    this.formMapping = formMapping;
    console.log('FormProcessor initialized with field mappings');
  }

  /**
   * Initialize header mappings from the spreadsheet's first row
   * @param headers - Array of header names from the spreadsheet
   */
  initializeHeaders(headers: string[]): void {
    console.log('Initializing headers from spreadsheet...');
    this.headerRow = headers;
    this.headerIndices.clear();

    Object.entries(this.formMapping.headerNames).forEach(([key, headerName]) => {
      const index = this.headerRow.findIndex((h) => h === headerName);
      if (index !== -1) {
        this.headerIndices.set(key, index);
        console.log(`Mapped field "${key}" to column ${index + 1} (${headerName})`);
      } else {
        console.warn(`Warning: Could not find column for "${headerName}"`);
      }
    });
  }

  /**
   * Validate that all required headers are present in the spreadsheet
   * @returns Array of missing field names
   */
  validateHeaders(): string[] {
    console.log('Validating required headers...');
    const missingFields: string[] = [];
    Object.entries(this.formMapping.headerNames).forEach(([key, headerName]) => {
      if (!this.headerIndices.has(key)) {
        missingFields.push(headerName);
        console.warn(`Missing required field: ${headerName}`);
      }
    });
    return missingFields;
  }

  /**
   * Process team assignments from the form response
   * @param teamsString - Comma-separated list of teams
   * @returns Array of valid team names
   */
  processTeams(teamsString: string): TeamName[] {
    if (!teamsString) return [];

    const teams = teamsString
      .split(this.formMapping.validation.teams.separator)
      .map((team) => team.trim())
      .filter((team): team is TeamName => this.formMapping.validation.teams.validValues.includes(team));

    console.log(`Processed teams: ${teams.join(', ')}`);
    return teams;
  }

  /**
   * Process a single row from the form responses
   * @param row - Array of values from a spreadsheet row
   * @returns Processed person data or null if invalid/incomplete
   */
  processRow(row: string[]): PersonData | null {
    console.log('\nProcessing new form response...');

    const consentIndex = this.headerIndices.get('consent');
    if (consentIndex === undefined || !row[consentIndex]) {
      console.log('Skipping row: No consent value found');
      return null;
    }

    const consentValue =
      this.formMapping.validation.consent.transform?.(row[consentIndex]) ?? row[consentIndex].toLowerCase();
    if (!this.formMapping.validation.consent.validValues.some((valid) => consentValue.includes(valid))) {
      console.log(`Skipping row: Invalid consent value "${consentValue}"`);
      return null;
    }

    const getValue = (key: keyof typeof this.formMapping.headerNames): string => {
      const index = this.headerIndices.get(key);
      return index !== undefined ? row[index] || '' : '';
    };

    const teamsValue = getValue('teams');
    const teams = this.processTeams(teamsValue);

    const personData: PersonData = {
      timestamp: getValue('timestamp'),
      email: getValue('email'),
      consent: consentValue,
      firstName: getValue('firstName').trim(),
      lastName: getValue('lastName').trim(),
      about: getValue('about'),
      teams,
      socialLinks: {
        linkedin: getValue('linkedin'),
        twitter: getValue('twitter'),
        facebook: getValue('facebook'),
        website: getValue('website'),
      },
      profilePicture: getValue('profilePicture'),
    };

    console.log(`Processed data for ${personData.firstName} ${personData.lastName}`);
    console.log(`Teams assigned: ${teams.join(', ') || 'None'}`);

    return personData;
  }
}

/**
 * Loads service account credentials from environment or file
 * @returns Service account JSON as string
 * @throws Error if no credentials are found
 */
async function loadServiceAccount(): Promise<string> {
  console.log('Loading Google service account credentials...');

  if (process.env.GOOGLE_SERVICE_ACCOUNT) {
    console.log('Using service account from environment variable');
    return process.env.GOOGLE_SERVICE_ACCOUNT;
  }

  try {
    const serviceAccountPath = path.join(process.cwd(), 'service-account.json');
    console.log(`Attempting to load service account from: ${serviceAccountPath}`);
    return await fs.readFile(serviceAccountPath, 'utf-8');
  } catch (error) {
    throw new Error(
      'No service account credentials found. Please set GOOGLE_SERVICE_ACCOUNT environment variable or create service-account.json',
    );
  }
}

/**
 * Loads and validates configuration from environment and files
 * @returns Validated configuration object
 * @throws Error if required configuration is missing
 */
async function getConfig(): Promise<Config> {
  console.log('Loading configuration...');

  try {
    const envPath = path.join(process.cwd(), '.env');
    console.log(`Checking for .env file at: ${envPath}`);
    const envContent = await fs.readFile(envPath, 'utf-8');
    envContent.split('\n').forEach((line) => {
      const [key, value] = line.split('=');
      if (key && value) {
        process.env[key.trim()] = value.trim();
        console.log(`Loaded environment variable: ${key.trim()}`);
      }
    });
  } catch (error) {
    console.log('No .env file found, continuing with environment variables');
  }

  let formMapping = DEFAULT_FORM_MAPPING;
  try {
    const mappingPath = path.join(process.cwd(), 'form-mapping.json');
    console.log(`Checking for form mapping configuration at: ${mappingPath}`);
    const mappingContent = await fs.readFile(mappingPath, 'utf-8');
    formMapping = {
      ...DEFAULT_FORM_MAPPING,
      ...JSON.parse(mappingContent),
    };
    console.log('Custom form mapping loaded successfully');
  } catch (error) {
    console.log('Using default form field mapping');
  }

  const config: Config = {
    spreadsheetId: process.env.GOOGLE_SHEET_ID || '',
    outputDir: path.join(process.cwd(), 'content', 'who-we-are', 'team', 'people'),
    imagesDir: path.join(process.cwd(), 'assets', 'images', 'people', 'profile-pictures'),
    teamsIndexPath: path.join(process.cwd(), 'content', 'who-we-are', 'team', '_index.en.md'),
    formMapping,
  };

  if (!config.spreadsheetId) {
    throw new Error('Missing required environment variable: GOOGLE_SHEET_ID');
  }

  console.log('Configuration loaded successfully');
  console.log(`Output directory: ${config.outputDir}`);
  console.log(`Images directory: ${config.imagesDir}`);
  console.log(`Teams index path: ${config.teamsIndexPath}`);

  return config;
}

/**
 * Creates an authenticated Google API client
 * @returns Authenticated Google Auth client
 */
async function getAuthClient() {
  console.log('Initializing Google Auth client...');
  const serviceAccountJson = await loadServiceAccount();
  return new google.auth.GoogleAuth({
    credentials: JSON.parse(serviceAccountJson),
    scopes: SCOPES,
  });
}

/**
 * Downloads and processes an image from Google Drive
 * @param url - Google Drive URL of the image
 * @param outputPath - Base path where the image should be saved
 * @returns Path to the saved image file
 * @throws Error if download or processing fails
 */
async function downloadImage(url: string, outputPath: string): Promise<string> {
  console.log(`\nProcessing image from URL: ${url}`);

  const fileId = url.match(/\/d\/([^/]+)/)?.[1] || url.match(/id=([^&]+)/)?.[1];

  if (!fileId) {
    throw new Error(`Invalid Google Drive URL: ${url}`);
  }

  console.log(`Extracted file ID: ${fileId}`);

  const auth = await getAuthClient();
  const drive = google.drive({ version: 'v3', auth });

  console.log('Fetching file metadata...');
  const metadata = await drive.files.get({
    fileId: fileId,
    fields: 'name,mimeType',
  });

  console.log('Downloading file content...');
  const response = (await drive.files.get(
    {
      fileId: fileId,
      alt: 'media',
    },
    {
      responseType: 'arraybuffer',
    },
  )) as GaxiosResponse<ArrayBuffer>;

  if (!response.data) {
    throw new Error('No data received from Google Drive');
  }

  const buffer = Buffer.from(response.data);
  console.log(`Downloaded file size: ${buffer.length} bytes`);

  const contentHash = createHash('sha256').update(buffer).digest('hex');
  console.log(`Generated content hash: ${contentHash}`);

  const originalExt = path.extname(metadata.data.name || '') || '.jpg';
  const dir = path.dirname(outputPath);
  const nameBase = path.basename(outputPath, path.extname(outputPath));
  const finalPath = path.join(dir, `${nameBase}-${contentHash}${originalExt}`);

  console.log(`Saving image to: ${finalPath}`);
  await fs.writeFile(finalPath, buffer);

  return finalPath;
}

/**
 * Updates the teams index file with new member assignments
 * @param config - Global configuration object
 * @param updatedPeople - Map of processed people data
 */
async function updateTeamsIndex(config: Config, updatedPeople: Map<string, PersonData>): Promise<void> {
  console.log('\nUpdating teams index file...');

  const indexContent = await fs.readFile(config.teamsIndexPath, 'utf8');
  const { data: frontmatter } = matter(indexContent);

  const teamsIndex = frontmatter as TeamsIndex;

  console.log('Processing team assignments...');
  teamsIndex.teams = teamsIndex.teams.map((team) => {
    console.log(`\nUpdating team: ${team.title}`);

    // Keep existing members that aren't in the updated list
    const existingMembers = team.members.filter((member) => {
      const personName = path.basename(member);
      return !Array.from(updatedPeople.keys()).includes(personName);
    });
    console.log(`Retained ${existingMembers.length} existing members`);

    // Add new members for this team
    const newMembers = Array.from(updatedPeople.entries())
      .filter(([_, data]) => data.teams.includes(team.title as TeamName))
      .map(([filename, _]) => `/who-we-are/team/people/${filename}`);
    console.log(`Adding ${newMembers.length} new members`);

    const sortedMembers = [...existingMembers, ...newMembers].sort((a, b) => {
      const isWinkoA = path.basename(a).toLowerCase().startsWith('winko');
      const isWinkoB = path.basename(b).toLowerCase().startsWith('winko');

      if (isWinkoA && !isWinkoB) return -1;
      if (!isWinkoA && isWinkoB) return 1;
      return a.localeCompare(b);
    });

    return {
      ...team,
      members: sortedMembers,
    };
  });

  console.log('Writing updated teams index file...');
  const updatedContent = matter.stringify('', teamsIndex);
  await fs.writeFile(config.teamsIndexPath, updatedContent);
  console.log('Teams index file updated successfully');
}

/**
 * Main function to process form responses and generate content
 */
async function processFormResponses(): Promise<void> {
  console.log('Starting form response processing...');

  const config = await getConfig();
  const auth = await getAuthClient();
  const sheets = google.sheets({ version: 'v4', auth });

  console.log('Fetching spreadsheet metadata...');
  const metadata = await sheets.spreadsheets.get({
    spreadsheetId: config.spreadsheetId,
    ranges: [],
    includeGridData: false,
  });

  const firstSheet = metadata.data.sheets?.[0];
  if (!firstSheet?.properties?.title) {
    throw new Error('Could not determine sheet title');
  }

  console.log(`Using sheet: ${firstSheet.properties.title}`);
  const formProcessor = new FormProcessor(config.formMapping);

  console.log('Fetching form responses...');
  const response = await sheets.spreadsheets.values.get({
    spreadsheetId: config.spreadsheetId,
    range: `${firstSheet.properties.title}!A:Z`,
  });

  const rows = response.data.values;
  if (!rows || rows.length < 2) {
    throw new Error('Sheet appears to be empty or contains insufficient data');
  }

  console.log(`Found ${rows.length - 1} form responses`);
  formProcessor.initializeHeaders(rows[0]);

  const missingFields = formProcessor.validateHeaders();
  if (missingFields.length > 0) {
    throw new Error(`Missing required form fields: ${missingFields.join(', ')}`);
  }

  console.log('Creating output directories...');
  await fs.mkdir(config.outputDir, { recursive: true });
  await fs.mkdir(config.imagesDir, { recursive: true });

  const updatedPeople = new Map<string, PersonData>();
  console.log('\nProcessing individual responses...');

  for (const row of rows.slice(1)) {
    const personData = formProcessor.processRow(row);
    if (!personData) continue;

    const { firstName, lastName } = personData;
    if (!firstName || !lastName) {
      console.log('Skipping response: Missing first or last name');
      continue;
    }

    const baseFileName = `${firstName.toLowerCase()}-${lastName.toLowerCase()}`;
    console.log(`\nProcessing entry for: ${firstName} ${lastName}`);

    let localImagePath = '';
    if (personData.profilePicture) {
      try {
        const fullImagePath = path.join(config.imagesDir, baseFileName);
        const savedPath = await downloadImage(personData.profilePicture, fullImagePath);
        localImagePath = path.join('images', 'people', 'profile-pictures', path.basename(savedPath));
        console.log(`Profile picture processed: ${localImagePath}`);
      } catch (error) {
        console.error(`Failed to download image for ${firstName} ${lastName}:`, error);
      }
    }

    const frontMatter: PeopleMarkdownFrontmatter = {
      type: 'people',
      title: `${firstName} ${lastName}`,
      image: localImagePath ? `/${localImagePath}` : '',
      role: 'Volunteer',
      intro: personData.about,
      links: Object.entries(personData.socialLinks)
        .filter(([_, url]) => url)
        .map(([platform, url]) => ({
          platform: platform as SocialPlatform,
          url: url as string,
        })),
      csirt_cases: [],
      csirt_posts: [],
      cve_records: [],
      description: personData.about,
    };

    const markdown = matter.stringify('', frontMatter);
    const filename = `${baseFileName}.md`;
    await fs.writeFile(path.join(config.outputDir, filename), markdown);

    updatedPeople.set(filename.replace('.md', ''), personData);
    console.log(`Generated markdown file: ${filename}`);
  }

  // Update teams index
  await updateTeamsIndex(config, updatedPeople);
  console.log('\nScript execution completed successfully');
}

processFormResponses().catch((error) => {
  console.error('Error processing form responses:', error);
  process.exit(1);
});
